---
layout: post
title: "[하이버네이트] Session-Per-XXX"
date: 2009-06-27 08:52:18.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Chapter 11
tags:
- session-per-conversation
- session-per-operation
- session-per-request
- 하이버네이트
meta:
  arkayne-cache-post: |2+







    <!-- BlogGlue Plugin Error -->
    <!-- This page cannot be linked by BlogGlue. -->
    <!-- You need a valid token. Get one at the URL below. -->
    <!-- http://www.blogglue.com/login/ -->

















  arkayne-time-post: '1322847420'
author:
  login: whiteship
  email: whiteship2000@gmail.com
  display_name: 기선
  first_name: 기선
  last_name: 백
---
<p>참조: JPWH 11장</p>
<p>Session-Per-Operation: 479p. 안티 패턴, 하나의 오펴레이션(메서드) 당 새로운 세션을 만들어 사용하는 것. 성능상 병목지점이 될 수 있다.</p>
<p>Session-Per-Request: 479p. pesistence context 범위를 데이터베이스 트랜재션 범위와 동일하게 유지하는 것. 즉 트랜잭션 당 새로운 세션을 만들어 사용하는 것으로 볼 수 있다. 짧은 conversation(하나의 request-response 쌍)을 처리할 때 적당하다.</p>
<p>Session-Per-Conversation: 489p. persistence context를 복잡한 conversation(여러 request-response 쌍) 스콥으로 확장(extending)하는 방법. conversation 마다 새로운 session을 만든다. detached 객체를 사용하여 conversation을 구현하는 방법의 대안책이 될 수 있다.</p>
<p>ps: 복잡하다. persist(), saveOrUpdate()가 괜히 있는게 아니였다. SPC의 경우 인터셉터를 이용할 수 있고, currentSession을 어딘가에 저장해 두었다가 다음 request 처리시에 재사용해야 한다. 또한, detached 객체를 사용한 Conversation 구현과, SPC를 사용한 Conversation 구현은 맘대로 정하는게 아니다. 경우에 따라, SPC를 사용해야만 하는 경우가 있다. 자세한건.. 내일??</p>
