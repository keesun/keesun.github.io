---
layout: post
title: The More Things Change The More They Stay The Same
date: 2008-01-24 09:04:24.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- vs Java
tags:
- c#
- 자바와 비교
meta:
  arkayne-cache-post: |2+







    <!-- BlogGlue Plugin Error -->
    <!-- This page cannot be linked by BlogGlue. -->
    <!-- You need a valid token. Get one at the URL below. -->
    <!-- http://www.blogglue.com/login/ -->

















  arkayne-time-post: '1323092820'
author:
  login: whiteship
  email: whiteship2000@gmail.com
  display_name: 기선
  first_name: 기선
  last_name: 백
---
<p>참조 : <a href="http://www.25hoursaday.com/CsharpVsJava.html" target="_blank">A COMPARISON OF MICROSOFT'S C# PROGRAMMING LANGUAGE TO SUN MICROSYSTEMS' JAVA PROGRAMMING LANGUAGE</a></p>
<p><span style="font-weight: bold;">1. We Are All Objects</span></p>
<p>- java.lang.Object와 비슷한 클래스 System.Object<br />- 모든 클래스들의 슈퍼 클래스.<br />- 메소드 이름이 대문자로 시작하는 군.<br />- object 키워드 == System.Object</p>
<p><span style="font-weight: bold;">2. Keyword Jumble</span></p>
<p>- 자바에는 없는 키워드가 C#에는 많이 있군.<br />자바 -&gt; C#<br />extends, implements -&gt; :<br />boolean -&gt; bool<br />final -&gt; sealed<br />protected -&gt; internal (C#의 protected는 다른 의미인듯..)</p>
<p><span style="font-weight: bold;">3. Of Virtual Machines and Language Runtimes</span></p>
<p>- 자바 소스 코드 -&gt; 바이트 코드 -&gt; Run in JVM<br />- C# 소스 코드 -&gt; IL(Intermediated Language) -&gt; Run in CLR(Common Language Runtime)</p>
<p><span style="font-weight: bold;">4. Heap Based Classes and Garbage Collection</span></p>
<p>- 자바는 new 키워드를 사용해서 모든 객체를 힙 영역에 생성.<br />- C#도 new 키워드를 사용해서 일부 클레스의 객체를 힙 영역에 생성.<br />- JVM 처럼 CLR도&nbsp; <a href="http://www.brpreiss.com/books/opus5/html/page424.html#secgarbagemarksweep" target="_blank">Mark and Compact garbage collection algorithm</a> 사용해서 Gabage Collection을 수행한다.<br />- value 타입은 stack에 생성할 수도 있나보다.</p>
<p><span style="font-weight: bold;">5. Arrays Can Be Jagged</span></p>
<p>- C나 C++의 다차원 배열에서 배열은 꼭 같은 길이의 배열을 가져야 했다.<br />- C#과 Java는 배열이 다른 길이의 배열을 가지고 있어도 된다.<br />int [][]myArray = new int[2][]; <br />myArray[0] = new int[3]; <br />myArray[1] = new int[9];</p>
<p><span style="font-weight: bold;">6. No Global Methods</span></p>
<p>- C++ 에서는 메소드가 클래스 밖에 있어도 됐나보다.<br />- C#은 자바처럼 메소드가 클래스의 멤버나 Static Method여야 한다.</p>
<p><span style="font-weight: bold;">7. Interfaces, Yes. Multiple Inheritance, No</span></p>
<p>- Java처럼 인터페이스는 다중 상속(구현)을 허용.<br />- Java처럼 상속은 다중 상속을 허용하지 않음.</p>
<p><span style="font-weight: bold;">8. Strings Are Immutable</span></p>
<p>- C#의 System.String은 Java의 java.lang.String과 비슷. 변하지 않는다.<br />- C#의 System.Text.StringBuilder는 Java의 java.lang.StringBuffer과 비슷.(동기화 시켜놓은 것도 비슷하려나;; 안했으면 StringBuilder랑 비슷한건데..)<br />- string 또는 String으로 표기할 수도 있다.</p>
<p><span style="font-weight: bold;">9. Unextendable Classes</span></p>
<p>- 자바에서 final 키워드를 class 앞에 붙이면 더이상 상속하지 못하는 클래스가 된다.<br />- C#에서는 sealed 키워드를 class 앞에 붙이면 된다.</p>
<p><span style="font-weight: bold;">10. Throwing and Catching Exceptions</span></p>
<p>- 자바와 동일하게 예외 클래스들의 최상위에 Exception 클래스를 제공한다.<br />- 예외를 감싸서 다시 던질 수 있다.</p>
<p><span style="font-weight: bold;">11. Member Initialization at Definition and Static Constructors</span></p>
<p>- 만약 멤버 변수가 인스턴스 변수이면, 생성자가 호출되기 전에 초기화 한다.<br />- Static 멤버들은 해당 멤버를 사용하기 전이나, 멤버가 속해있는 클래스의 객체를 만들기 조금 전에 초기화 한다.<br />- 인스턴스 변수를 생성하거나 Static 메소드를 호출하기 전에 특정 블럭을 실행하도록 하는 것도 가능하다.<br />- 자바에서는 이런 코드 블럭을 static 초기화 블럭이라고 한다.<br />- C#에서는 static 생성자라고 한다.(실제 모양도 생성자 모양.)</p>
<div style="border: 1px solid rgb(204, 204, 204); padding: 10px; background-color: rgb(247, 247, 247);">using System; </p>
<p>class StaticInitTest{</p>
<p>&nbsp; &nbsp; string instMember = InitInstance(); </p>
<p>&nbsp; &nbsp; string staMember = InitStatic(); <br />&nbsp; &nbsp; </p>
<p>&nbsp; &nbsp; StaticInitTest(){<br />&nbsp; &nbsp; Console.WriteLine("In instance constructor");<br />&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; static StaticInitTest(){<br />&nbsp; &nbsp; Console.WriteLine("In static constructor");<br />&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; static String InitInstance(){<br />&nbsp; &nbsp; Console.WriteLine("Initializing instance variable");<br />&nbsp; &nbsp; return "instance";<br />&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp;&nbsp; static String InitStatic(){<br />&nbsp; &nbsp; Console.WriteLine("Initializing static variable");<br />&nbsp; &nbsp; return "static";<br />&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; static void DoStuff(){<br />&nbsp; &nbsp; Console.WriteLine("Invoking static DoStuff() method");<br />&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; <br />&nbsp; &nbsp; public static void Main(string[] args){</p>
<p>&nbsp; &nbsp; Console.WriteLine("Beginning main()");</p>
<p>&nbsp; &nbsp; StaticInitTest.DoStuff(); <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; StaticInitTest sti = new StaticInitTest(); </p>
<p>&nbsp; &nbsp; Console.WriteLine("Completed main()");</p>
<p>&nbsp; &nbsp; }</p>
<p>}</p></div>
<p>
<div style="border: 1px solid rgb(204, 204, 204); padding: 10px; background-color: rgb(231, 231, 231);">In static constructor<br />Beginning main()<br />Invoking static DoStuff() method<br />Initializing instance variable<br />Initializing static variable<br />In instance constructor<br />Completed main()</div>
<p>이런 코드가 나온이유.</p>
<p>main() 메소드 실행하기 전에, static 생성자가 호출 된다.</p>
<p>In static constructor</p>
<p>그 다음 static 메소드를 호출할 때는 이미 static 생성자가 호출 됐기 때문에 그냥 메소드 호출.</p>
<p>Invoking static DoStuff() method</p>
<p>생성자가 호출되기 전에 인스턴스 변수들을 초기화 하기 때문에, new StaticInitTest(); 하는 순간 필드들을 초기화 하려고 하겠지.. 그래서..</p>
<p>Initializing instance variable<br />
Initializing static variable</p>
<p><span style="font-weight: bold;">12. Boxing</span></p>
<p>- .Net은 boxing, unboxing 그냥 된다.<br />- Java도 5 부터는 된다.<br />- C#에서도 Collection에는 객체만 들어갈 수 있군.</p>
