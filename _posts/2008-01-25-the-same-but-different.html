---
layout: post
title: The Same But Different
date: 2008-01-25 06:46:18.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- vs Java
tags:
- c#
- 자바 VS C#
meta:
  arkayne-cache-post: |2+







    <!-- BlogGlue Plugin Error -->
    <!-- This page cannot be linked by BlogGlue. -->
    <!-- You need a valid token. Get one at the URL below. -->
    <!-- http://www.blogglue.com/login/ -->

















  arkayne-time-post: '1323202250'
author:
  login: whiteship
  email: whiteship2000@gmail.com
  display_name: 기선
  first_name: 기선
  last_name: 백
---
<p><span style="font-weight: bold;">1. Main Method</span></p>
<p>- Java와 C# 모두 메인 메소드가 진입점이다.<br />- C#의 메소드 작명 지침에 따라 Main 메소드 이름이 M 대문자로 시작한다.<br />- C#의 Main 메소드는 인자로 아무것도 안 가질 수 있다.</p>
<p>public static void Main() {}</p>
<p>- C#에서는 실행 파일 만들 때, /main 옵셥을 사용해서 집입점을 선택할 수 있다.<br />- 실행 파일의 이름이 소스 파일 이름과 달라도 되네.. 거의 Java의 JAR파일이랑 EXE랑 비슷하네.. </p>
<p><img src="{{ site.baseurl }}/assets/gk40.png" class="aligncenter" width="600" height="306" alt="사용자 삽입 이미지" /><br /><span style="font-weight: bold;">2. Inheritance Syntax</span></p>
<p>- Java 처럼 상속은 extends, 인터페이스 구현은 implements 로 구분하지 않는다.<br />- 그냥 : 로 둘 다 나타낸다. 대신 인터페이스는 .Net 작명 지침 상 대문자 I를 클래스 이름 맨 앞에 붙여주니까, 인터페이스 구현인지 상속인지 구분 할 수 있다.</p>
<p><span style="font-weight: bold;">3. Run Time Type Identification (is operator)</span></p>
<p>- Java의 instanceof 연산자는 C#에서 is(짧아서 좋네.)</p>
<p>&nbsp; if(x is MyClass)<br />&nbsp;&nbsp; MyClass mc = (MyClass) x;</p>
<p><span style="font-weight: bold;">4. Namespaces</span></p>
<p>- Java의 package 이름은 물리적인 폴더 구조와 일치 해야 한다.<br />- C#의 namespace는 논리적인 구조를 나타내며, namespace안에 namespace를 추가할 수 있다.</p>
<p>&nbsp; &nbsp; namespace Whiteship<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; public class A { }<br />&nbsp; &nbsp; &nbsp; &nbsp; public class B { }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; namespace Sun <br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public class A { }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public class B { }<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }</p>
<p><span style="font-weight: bold;">5. Constructors, Destructors and Finalizers</span></p>
<p>- C#의 생성자는 Java의 생성자와 모양과 뜻이 같다.<br />- C#의 Destructor는 C++ 문법을 사용하지만 뜻은 Java와 더 비슷하다.(GC를 명시적으로 호출하지 않기 때문에 언제 호출 될지 예측할 수 없기 때문인가?)<br />- C#의 Destructor는 클래스 이름 앞에 ~를 붙인다.<br />- In C#, destructors(finalizers) automatically call the base class finalizer after executing which is not the case in Java.(???)<br /><br style="font-weight: bold;" /><span style="font-weight: bold;">6. Synchronizing Methods and Code Blocks</span></p>
<p>- Java의 synchronized 블럭과 동일한 것을 C#에서는 lock 키워드를 사용한다.<br />- 동기화 메소드는 Java에서 synchronized 키워드를 메소드 이름 앞에 붙여주는데, C#에서는 [MethodImpl(MethodImplOptions.Synchronized)] 애노테이션을 붙인다.<br />- using System.Runtime.CompilerServices; 붙여 줘야 함.<br /><br style="font-weight: bold;" /><span style="font-weight: bold;">7. Access Modifiers</span></p>
<p>- (참조 한 곳에서 Java의 접근 지시자를 잘못알고 있는 듯..)<br />- C#의 public은 Java의 public<br />- C#의 private은 Java의 private<br />- C#의 protected는 Java의 protected(상속 받은 클래스들에서 참조 가능)</p>
<p>- C#의 default는 private 이지만, Java의 default는 default(같은 패키지에서만 참조 가능)<br />- C#의 internal은 같은 assmbly에서만 참조 가능.<br />- C#의 internal protected는 같은 자기 자신과 assembly와 상속받은 클래스에서 참조 가능.</p>
<p><span style="font-weight: bold;">8. Reflection</span></p>
<p>- C# is done at the <a href="http://www.25hoursaday.com/CsharpVsJava.html#assemblies"><br />
        assembly</a> level while reflection in Java is done at the<br />
        class level.<br />- C#은 타겟 클래스를 담고 있는 DLL 파일이 필요해.<br />- Java의 Class는 C#의 Type</p>
<p>Type type = typeOf(MyClass);</p>
<p>- 동적으로 생성되는 타입은 어떻게 알아내지?</p>
<p>ICollection a = new ArrayList();<br />Type type = typeOf(a); //이런건 안되던데;;</p>
<p><span style="font-weight: bold;">9. Declaring Constants</span></p>
<p>- Java는 컴파일 시점에 설정거나 실행중에 설정할 상수 모두를 final로 나타낸다.<br />- C#에서 컴파일 시점에 설정할 상수는 const 키워드를 사용하고 실행 중에 설정할 상수는 readonly&nbsp; 키워드를 사용한다.<br />- primitive 타입 상수와 reference 타입 상수에 대한 개념은 Java와 동일하다.<br />- Java에서는 메소드의 파라미터도 final을 붙일 수 있는데 C#에서는 그런 기능이 없다.(그럼 C#은 inner class에 참조 할 때 final 안붙여도 상관없나..)</p>
<p><span style="font-weight: bold;">10. Primitive Types</span></p>
<p>- Java의 byte 는 C#에서 sbyte<br />- C#에서는 unsigned 타입을 제공한다. uint, ulong, ushort, byte<br />- C#에서는 decimal 타입을 제공한다. 더 정확하고 더 많은 공간과 시간을 소비한다. 값뒤에 d를 붙여준다.</p>
<p><span style="font-weight: bold;">11. Array Declarations</span></p>
<p>- C#에서는 다음과 같은 문법으로만 배열을 생성할 수 있다.<br />int[] iArray = new int[100];<br />- Java에서는 아래처럼 해도 되지만, C#에서는 안 된다.<br />float fArray[] = new float[100];</p>
<p><span style="font-weight: bold;">12. Calling Base Class Constructors and Constructor Chaining</span></p>
<p>- Java와 마찬가지로 상위 클래스의 생성자 호출은 제일 먼저 실행되어야 한다.(그래야 초기화 되지 않은 변수를 가져다 쓰는 일이 벌어지지 않을테니까..)<br />- 생성자 안에서 자기가 가지고 있는 다른 생성자를 호출하는 것을 Constructor Chaining 이라고 한다.<br />- 생성자 바디에 넣는게 아니라 아예 메소드 시그너쳐 바로 옆에 붙여주는 군..</p>
<p>MyException(string message): this(message, null){}<br />MyException(string message, Exception innerException): base(message, innerException){}</p>
<p><span style="font-weight: bold;">13. Variable Length Parameter Lists</span></p>
<p>- 가변인자를 Java에서는 ... 을 사용해서 여러개의 파라미터를 배열에 받아 올 수 있다.<br />- C#에서는 params 키워드를 사용하며 배열 타잎 앞에 붙여준다.</p>
<p>public void printTitleAndNums(string title, params int[] nums){}</p>
<p><span style="font-weight: bold;">14. Generics</span></p>
<p>- Although similar in concept to templates in C++, the Generics feature in C# and Java is not implemented similarly</p>
<p>- Java는 type erasure(컴파일 이후에는 Generic을 삭제하고 Object 타입으로 동작한다. 알아서 해당 타입으로 캐스팅 해준다.)를 사용해서 generic 기능을 구현했다.<br />- 기존 코드legacy code와의 호환interoperability 때문에 이렇게 구현했다.<br />&nbsp; &nbsp; -&nbsp; 런타임 시에 타입을 알 수 없다는 단점이 있다. 리플랙션으로 알아낼 수가 없다.<br />&nbsp; &nbsp; - 항상 객체 타입이어야 한다. 따라서 정수형이 필요할 때, Collection&lt;int&gt;가 아니라 Collection&lt;Integer&gt;를 사용해야 한다.</p>
<p>- C#은 .NET 런타임의 Instruction Language(IL)의 지원을 받는다. Generic 타입이 컴파일 되면, 만들어진 IL이 특정 타입에 대한 Placeholder를 가지고 있다. Generic 타입에 대한 레퍼런스 초기화 요청이 오면 Placeholder에 해당 타입이 있는지 확인하고 있으면, 그것을 돌려주고 없으면 Generic 타입 파라미터를 요청한 타입으로 바꿔준다. 이때 요청 받은 타입이 Reference 타입일 경우에는 Generic 타입 파라미터를 Object로 바꿔주지만, 해당 타입에 접근할 때 캐스팅을 하지는 않는다.(캐스팅 하지 않고도 해당 타입의 멤버에 접근할 수가 있나..??)<br />=&gt; C#은 value 타입을 Generic 타입으로 사용할 수 있다.<br />=&gt; C#은 런타임시에 Generic 타입을 알 수 있다.</p>
<p>- Java의 와일드카드 타입 ? 은 C#의 generic type inferencing</p>
<p>- C#와 Java 모두 Generic 타입에 제약을 가할 수 있다.<br />&nbsp; &nbsp; - derivation constraint: 하위 제한으로 특정 인터페이스나 클래스를 구현하거나 상속받은 클래스로 제한하기<br />&nbsp; &nbsp; - default constructor constraint:&nbsp; public 기본 생성자를 가진 클래스로 제한<br />&nbsp; &nbsp; - reference/value type constraint constrains: Generic 타입 파라미터를 reference나 value 타입으로 제한.</p>
<p>- C#은 default 연산자를 제공한다. reference 타입은 null, value 타입은 0과 공백을 리턴한다.</p>
<p><span style="font-weight: bold;">15. for-each Loop</span></p>
<p>- 배열이나 System.Collections.IEnumerable를 구현한 클래스 타입을 간단하게 순회할 수 있다.<br />- C#에서는 foreach&nbsp; 와 in을 사용한다.</p>
<p>foreach(int num in nums)<br />Console.WriteLine(num);</p>
<p><span style="font-weight: bold;">16. Metadata Annotations</span></p>
<p>- [MethodImpl(MethodImplOptions.Synchronized)]: 동시에 여러 쓰레드가 해당 메소드를 사용하는 것을 막기 위해서 사용.<br />- [Serializable]: Java의 Serializable 인터페이스와 같은 효과.<br />- [FlagsAttribute]: 비트와이즈 연산을 지원해야 한드는 의미로, Enumerarion위에 붙여준다.<br />- [WebMethod]: ASP.NET에서 사용하는데, 이걸 메소드 위에 붙이면 자동으로 웹에서 웹 서비스로 사용할 수 있다.<br />- 리플랙션을 사용해서 모듈, 클래스, 메소드, 필드에 붙어있는 어트리뷰트에 접근하는 것이 가능하다.(자바도 가능)<br />- System.Attribute 클래스를 상속해서 원하는 어트리뷰트를 만들 수도 있다.</p>
<p>- Java는 Meta Annotation을 만들 수 있지만, C#은 못한다.</p>
<p><span style="font-weight: bold;">17. Enumerations</span></p>
<p>- Java의 Enum은 Type-Safe하고, 필드와 메소드를 추가할 수 있고, 인터페이스를 구현하는 것도 가능하다.<br />- C#에서는 그냥 int 값이다. 따라서 Type-Safe하지 못하다.<br />- Console.WriteLine()으로 찍으면 문자로 찍히는데.. int 값을 Enum 타입으로 형변환 해버릴 수 있다. 그런 다음에 찍으면 숫자가 찍힌다.</p>
