---
layout: post
title: EJ2E Item 16. 상속보다 컴포지션을 선호하라
date: 2008-12-27 15:25:43.000000000 -08:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Java
tags:
- Composition
- effective java
- extends
- item 16
meta:
  arkayne-cache-post: |2+







    <!-- BlogGlue Plugin Error -->
    <!-- This page cannot be linked by BlogGlue. -->
    <!-- You need a valid token. Get one at the URL below. -->
    <!-- http://www.blogglue.com/login/ -->

















  arkayne-time-post: '1322966273'
author:
  login: whiteship
  email: whiteship2000@gmail.com
  display_name: 기선
  first_name: 기선
  last_name: 백
---
<p>참조: Effective Java 2nd Edition Item 16: Favor composition over inheritence</p>
<p>상속<br />- 상속은 코드 재사용을 하는 강력한 방법이지만 항상 최선의 방법은 아니다. 무분별하게 사용했다가는 연약한 소프트웨어가 된다.</p>
<p>- 상속은 동일한 패키지 내에서 하위 클래스와 상위 클래스 구현을 같은 프로그래머가 관리할 때 안전하다. 또한 상속은 상속하려는 클래스가 확장을 고려해서 설계되었고 문서화 되어 있을 때 안전하다.</p>
<p>- 이 책에서 말하는 상속은 구현체 간의 상속이지 인터페이스 상속을 말하는 건 아니다.</p>
<p>- 메소드 호출과 달리 상속은 캡슐활르 위반한다. 즉 하위 클래스가 상위 클래스의 구현에 의존한다.&nbsp; 상위 클래스의 구현 내용이 배포를 거듭하면서 바뀔 수 있는데.. 이로 인해 하위 클래스 코드는 건드리지도 않았는데 깨질 수가 있다.</p>
<p>- 오직 "is-a" 관계가 성립할 때만 적당하다. 자바 플랫폼에서 이를 위반 한 사례: Stack이 Vector를 상속받았다. Properties가 Hashtable을 상속 받았다.</p>
<p>컴포지션<br />- 컴포지션을 사용하면 앞서 말한 문제(깨지기 쉬운 코드, 상위 클래스에 새로운 메소드 추가 필요)를 해결할 수 있다.</p>
<p>- 포워딩(흔히 역할 위임이라고 일컫는 작업을 나타내는 듯)을 한다. </p>
<p>- 구현의 구체적인 내용과는 의존성이 없다.</p>
<p>- 래퍼(wrapper) 클래스와 데코레이터 패턴</p>
<p>- 래퍼 클래스 단점: 래퍼 클래스는 콜백 프레임워크에서 사용하기 적당하지 않다. 래퍼 클래스로 감싼 객체는 자기가 누구한테 감싸였는지 모르기 때문에 itself(this) 형태로 호출해도 래퍼는 무시된다. (만약 상속이었다면? 다형성 때문에 결국 상위 클래스를 상속받은 하위 클래스의 객체가 넘어갔겠지만..) =&gt; SELF problem</p>
