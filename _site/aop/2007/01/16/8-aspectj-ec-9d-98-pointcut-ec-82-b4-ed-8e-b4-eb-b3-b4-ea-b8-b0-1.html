<p>참조 : <a href="http://static.springframework.org/spring/docs/2.0.x/reference/aop.html#aop-pointcuts-examples" target="_blank">Spring Reference 6.2.3.4</a></p>
<div style="padding: 10px; background-color: rgb(250, 255, 169);"><span style="font-weight: bold;">execution(modifiers-pattern? </span><span style="color: rgb(255, 0, 0); font-weight: bold;">ret-type-pattern</span><span style="font-weight: bold;"> declaring-type-pattern? name-pattern(param-pattern)          throws-pattern?)</span></div>
<ul>
<li>빨간색으로 표시된 return type pattern을 제외 하고는 전부 optional입니다. </li>
</ul>
<ul>
<li>modifiers-pattern은 advice가 적용될 메소드의 접근 지시자 형태를 정합니다. * 은 모든 메소드 public은 public 메소드만... 뭐 그런 식입니다.</li>
</ul>
<ul>
<li>declaring-type-pattern은 인터페이스나 패키지 패턴을 나타내는 부분인듯 합니다.</li>
</ul>
<ul>
<li>name-pattern은 메소드의 이름의 형태를 지정해 줍니다. set* 과 같이 하면 set으로 시작하는 모든 메소드를 나타냅니다.</li>
</ul>
<ul>
<li>param-pattern은 조금 특이합니다. ()은 파라미터가 없는 메소드를 가리키고, (..)는 파라미터가 어떤 형태든 몇 개든 상관없슴을 나타냅니다. 다른 패턴들이 * 와일드 카드를 사용하는 것과는 차이가 있네요. (*, String) 이것은 파라미터가 두 개고 첫번 째 파라미터의 타입은 상관이 없고 두 번째 파라미터의 타입이 String인 메소드를 나타냅니다.</li>
</ul>
<div style="padding: 10px; background-color: rgb(250, 255, 169);"><span style="font-weight: bold;">within(type-pattern)</span></div>
<ul>
<li>within은 Spring AOP가 메소드 execution 포인트컷만 지원하기 때문에 해당 타입과 관련된 모든 메소드 실행시점을 가리키게 됩니다. AspectJ를 사용할 때는 훨씬 다양한 포인트컷[footnote]클래스 초기화 시점, 객체 초기화 시점, 생성자 실행 시점, 메소드 실행 시점 이밖에도 변수들에 대한 포인트컷까지 적용되며 내부 클래스가 있을 경우 그 것의 생성자나 기타 내부 클래스와 관련된 모든 join point에도 적용 됩니다.[/footnote]을 나타내게 됩니다.</li>
</ul>
<ul>
<li>within(com.xyz.service.*) 이것 같은 경우는 com.xyz.service 패키지 안에 있는 모든 클래스의 모든 메소드의 실행 시점을 나타냅니다.</li>
</ul>
