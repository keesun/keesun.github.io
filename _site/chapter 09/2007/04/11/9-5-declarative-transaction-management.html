<p>Spring도 EJB의 CMT 처럼 선언적인 트랜잭션을 제공하지만 몇 가지 차이가 있습니다.
<ul>
<li>Spring은 EJB의 CMT 처럼 JTA에 종속되어 있지 않습니다. 설정 내용을 살짝 바꾸기만 하면 JDBC, Hibernate, JDO 등을 자유롭게 사용할 수 있습니다.</li>
<li>EJB(bean) 만 트랜잭션을 처리할 수 있었는데 반해 Spring은 일반 클래스에도 적용할 수 있습니다.</li>
<li>선언적으로 롤백 룰을 설정할 수 있습니다.</li>
<li>AOP를 사용하여 트랜잭션 처리를 할 때 사용자가 원하는 부가적인 기능을 실행할 수 있습니다. EJB에서는 할 수 없습니다.</li>
<li>The Spring Framework does not support propagation of transaction contexts<br />
                across remote calls, as do high-end application servers</li>
</ul>
<p>롤백 룰을 사용하여 특정 예외가 발생했을 때에만 롤백이 되도록 선언적으로 지정할 수 있습니다.</p>
<p>EJB의 경우 기본 설정이 RemoteException를 제외한 checked 예외(application exception)가 발생하면 롤백하지 않고 Runtime exception(system exception)이 발생하면 자동으로 롤백하도록 되어 있습니다.</p>
<p>이런 기본 설정이 유용하기 때문에 Spring도 EJB의 기본 설정을 따라서 unchecked exception 가 발생할 때에만 자동으로 롤백하도록 기본 설정되어 있습니다.</p>
<p>9.5.1. Understanding the Spring Framework's declarative transaction implementation</p>
<p>Spring의 선언적인 트랜잭션 관리라는 신비를 파해칩니다.</p>
<p>9.5.2. A first example</p>
<p>예제 ㄱㄱ..</p>
<p>9.5.3. Rolling back</p>
<p>간단한 설정을 통해서 롤백을 제어 하는 방법을 설명합니다.</p>
<p>9.5.4. Configuring different transactional semantics for different beans</p>
<p>여러 bean들에 각각 다른 트랜잭션을 적용하는 방법을 설명합니다.</p>
<p>9.5.5. &lt;tx:advice/&gt; settings</p>
<p>&lt;tx:advice/&gt; 태그를 사용하여 트랜잭션 속성을 설정합니다.</p>
<p>9.5.6. Using @Transactional</p>
<p>@Transactional 어노테이션을 사용하여 XML 설정 대신 트랜잭션 대상이 될 bean을 지정할 수 있습니다.</p>
<p>9.5.7. Advising transactional operations</p>
<p>트랜잭션 처리를 해야하는 advice를 엮는 방법을 설명합니다.</p>
<p>9.5.8. Using @Transactional with AspectJ</p>
<p>Spring Container에서 관리하는 bean 말고도 AspectJ를 사용하여 @Trancsational 어노테이션을 적용할 수 있습니다.</p>
