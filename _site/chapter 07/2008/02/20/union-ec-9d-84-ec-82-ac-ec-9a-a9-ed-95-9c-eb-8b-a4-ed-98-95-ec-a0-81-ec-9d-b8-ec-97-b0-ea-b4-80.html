<h1>특징</h1>
<ul>
<li>Table Per Subclass와 Table Per Class Hierarchy에서의 다형적인 연관을 확인했다.</li>
</ul>
<ul>
<li>Table Per Concrete Class With Union에서도 똑같이 적용된다.</li>
</ul>
<div class="code panel" style="border-width: 1px;">
<div class="codeHeader panelHeader" style="border-bottom-width: 1px;"><b>콜렉션 테스트</b></div>
<div class="codeContent panelContent">
<pre class="code-java">@Test<br /><span class="code-keyword">public</span> void oneTomanyConfirm() <span class="code-keyword">throws</span> Exception {<br />	Session session = sessionFactory.openSession();<br />	<br />	User user = (User) session.get(User.class, 1l);<br />	Set&lt;BillingDetails&gt; bds = user.getBilllingDetailses();<br />	<span class="code-keyword">for</span>(BillingDetails bd : bds){<br />		<span class="code-object">System</span>.out.println(<span class="code-quote">".."</span>);<br />	}<br />	<br />	session.flush();<br />	session.close();<br />}</pre>
</div>
</div>
<div class="code panel" style="border-width: 1px;">
<div class="codeHeader panelHeader" style="border-bottom-width: 1px;"><b>단일 클래스 연관 테스트</b></div>
<div class="codeContent panelContent">
<pre class="code-java">@Test<br /><span class="code-keyword">public</span> void oneToOneConfirm() <span class="code-keyword">throws</span> Exception {<br />	Session session = sessionFactory.openSession();<br />	<br />	User user = (User) session.get(User.class, 1l);<br />	BillingDetails bd = user.getDefaultBillingDetails();<br />	bd.pay();<br />	<br />	session.flush();<br />	session.close();<br />}</pre>
</div>
</div>
<ul>
<li>@OneToOne 이나 @ManyToOne으로 상위 타입과 연관을 맺고 있을 때, 외례키 제약은<br />
하이버네이트가 만들어 줄 수 없다. 왜? 어떤 하위 클래스의 주키를 외례키로 가져야 하는지 판단하는게 쉽지 않다. 따라서<br />
사용자가 적당한 제약 사항을 만들어야 한다.</li>
</ul>
