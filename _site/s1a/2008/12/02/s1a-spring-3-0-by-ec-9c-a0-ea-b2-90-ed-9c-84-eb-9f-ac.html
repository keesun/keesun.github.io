<p>깊게 다루진 않겠다. 얇게thin 여러 기능 들을 살펴보겠다.</p>
<p>이번 주에 새 버전을 릴리즈 할 것이다.</p>
<p>Agenda <br />- 2.5 리뷰 <br />- 3.0 테마와 기능 <br />- </p>
<p>스프링 2.5 <br />- 다양한 애노테이션 기반 설정 지원<br />- Java EE 5 애노테이션 지원(ex. @EJB, @WebServiceRef... @PersistenceUnit/Context)<br />=&gt; 애노테이션의 시멘틱을 스프링 애플리케이션 문맥에 맞게 사용한다.<br />=&gt; 이름이 별론데 어쩌겠냐. 사용해야지.<br />=&gt; 스프링 2.5가 똑똑하게 애노테이션을 처리해준다.</p>
<p>애노테이션을 사용한 빈 컴포넌트<br />- 예제 코드(@service, @Autowired, @Transactiona)<br />=&gt; 미들웨어 서비스와 연결(@Transactional)</p>
<p>애노테이션을 사용한 라이프 사이클 관리 중인 DAO<br />- 예제 코드</p>
<p>XML 빈 설정 최고화 하기<br />- context:annotation-config<br />- context:component-scan<br />=&gt; 이런 모든 기능들은 3.0에서도 사용 가능하다.</p>
<p>테스트 컨텍스트 프레임워크<br />- 예제 코드</p>
<p>스프링 서블릿 MVC 2.5<br />- 예제 코드(ActionResponse.setRenderParameter("action", "list");</p>
<p>===============</p>
<p>스프링 3.0 테마<br />- 자바 5+ 기반: J2EE 1.4와 JEE 5 호환 =&gt; 코드를 다시 구현하고 싶진 않았다. 사용자에게는 변화가 없고, 스프링소스 팀 내에서 코딩하는 방법이 바뀐 것 분<br />- EL =&gt; 매우 중요한 변경 사항. 빈 설정할 때 매우 유용하게 사용할 수 있다. JSF Universal EL을 보고.. 이와 같은 아이디어를 스프링 웹 플로우팀과 공유했다. <br />- REST 지원<br />- Portlet 2.0 지원<br />- 선언적인 모델 검증: hibernate validator, JSR 303 =&gt; JSR 303은 그다지 많이 진전하지 않았지만.. 지원한다. <br />- Java EE 6 지원: JSF 2.0, JPA 2.0, .. =&gt; 스프링 2.5에서는 일찌감치 Java EE 5를 지원했었다.</p>
<p>새 프로젝트 레이아웃<br />- 수정한 프로엠워크 모듈(메이븐 스타일로 관리한다. 모듈 jar 별로 소스 트리 하나, spring.jar는 이제 없다!!!) =&gt; spring.jar는 시간이 흘러가면서 점점 일관성을 잃어가고 있다. &nbsp;spring.jar를 더이상 고치지 않겠다.<br />- Spring Web Flow 2.0으로 알려져있는 새로운 빌드 시스템으로 빌드했다.(배포 절차, 의존성 관리, OSGi manifest 생성)</p>
<p>빈 설정에서 EL<br />- 예제 코드 =&gt; 예를 들어, 맵에 있는 키값으로 그 맵의 요소 값을 참조 하거나 특정 빈의 메소스 실행 결과 값을 DI하는 것이 가능하다. 암묵적인 객체를 사용할 수도 있다(?)</p>
<p>컴포넌트 애노테이션에서 EL<br />- 예제 코드 =&gt; 기본값 설정에 사용할 수 있다. DI 할 것이 없으면 이 값을 사용하도록..., @Value는 매우 강력한 애노테이션으로 ...</p>
<p>스프링 EL 파서<br />- 스프링 3.0에 들어간다.<br />- Unified EL과 호환가능하지만 보다 강력하다</p>
<p>EL 문맥 속성<br />- 암묵적인 속성은 런타임 문맥에 따라 기본으로 사용이 가능하다.(ex. systemProperties, sustemEnvironment")</p>
<p>웹 문맥 속성<br />- contextProperties: web.xml init-param.<br />- ...<br />=&gt; 팩토리빈으로 사용하던 걸 훨씬 간단하게 사용할 수 있다.</p>
<p>REST 지원<br />- REST 스타일 맵핑 지원<br />- 대안 JAX-RS =&gt; 웹 서비스에 가깝다. </p>
<p>MVC에서 REST<br />- @PathVariable("id") long id =&gt; 2.5의 @ReqeustParam과 비슷하게 사용한다.<br />질문1: 타입이 어떻게 long이냐? 기본 컨버전 룰이 있다. <br />질문2: EL 파서 ...? no ..<br />=&gt; URL 이 복잡해지면 여러 개가 필요할 것이다. 여러 개 매개변수를 선언해서 사용하면 된다.</p>
<p>다양한 Representation<br />- JSON =&gt; 뷰 리졸버를 직접 구현해도 되지만, 이걸 스프링에서 직접 지원하고 싶었다.<br />- XML<br />- ATOM<br />=&gt; request의 accepts 헤더에 따라 다른 정보를 만들어 준다.</p>
<p>@MVC Refinements<br />- @RequestHeader<br />- @CookieValue<br />=&gt; 쿠키나 헤더가 필요할 때 HttpServletRequest를 사용했었어야 하는데 이젠 그럴 필요가 없다.<br />=&gt; mocking 할필요도 없고 단순하게 string이나 int값 사용하면 된다.</p>
<p>포틀릿 2.0 지원<br />- 이건 하나도 몰르는뎅;;<br />- Portlet 2.0 지원, 명시적인 맵핑 애노테이션 지원.</p>
<p>컨버세이션Conversation 관리<br />- 핵심 문제: isolating concurrent windows in same browser<br />=&gt; 스프링에서 뭘 할 수 있는지 조사를 했다.<br />- conversation 스코프(session보다 짧은 라이프사이클을 지니고 있다.)<br />=&gt; 스프링 웹 플로우 3.0이 이걸 기반으로 복잡한 플로우 네비게이션을 지원할 것이다.</p>
<p>빈 직렬화<br />- 스프링 2.5에서 session과 conversation 객체 직렬화 문제 =&gt; 서비스 퍼사드가 DAO를 참조할 때 DAO는 보통 직렬화 하지 않아서 서비스 직렬화 실패. 결국 전체 직렬화를 할 수 없다.<br />- 해결책: 프록시를 사용. 역직렬화해서 다시 가져온 레퍼런스를 프록시..한다. (?) 어렵네;; </p>
<p>모델 검증<br />- 화면에서 값 바인딩부터 랜더링, 영속화할 때까지 적용<br />- 하이버네이트 Validator API 사용가능<br />- JSR 303도 지원한다<br />@NotNull, @ShortDate</p>
<p>스프링 3,0과 Java EE 6<br />- JSF 2.0, JPA 2.0, JAX-RS/Jersey, JSR 236(쓰레드 풀 관리)<br />- 스프링 3.1/3.2는 Java EE 6 모든 기능 제공(Servlet 3.0, Web beans 애노테이션) </p>
<p>제 3 라이브러리 업데이트<br />- 하이버네이트 3.3, 이클립스링크 1.0 랴final</p>
<p>포트폴리오 정리<br />- 스프링 웹 서비스의 OXM 모듈을 개선한 걸 스프링 3.0에 포함 시킨다.<br />- 스프링 웹 플로우의 바인딩과 타입 컨버전을 스프링 3.0으로<br />- JavaConfig기능을 스프링 3.0으로..</p>
<p>Pruning(가지치기)와 Deprecation</p>
<p>스프링 2.5 미션은 계속 된다.<br />- 100% 호환 프로그래밍 모델,</p>
<p>요약</p>
<p>로드맵</p>
