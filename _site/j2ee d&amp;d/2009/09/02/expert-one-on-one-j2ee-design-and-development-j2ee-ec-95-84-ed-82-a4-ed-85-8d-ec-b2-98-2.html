<p><span style="font-weight: bold;"><span style="font-size: 10pt;">Accessing Data</span></span><br style="font-weight: bold;" /><br />
(예전) EJB를 사용하면 엔티티 빈이라는 하나의 선택지 밖에 없다. (EJB 3.0부터는 JPA가 있지요.)</p>
<p>J2EE Data Access Shibboleths</p>
<p>- 데이터베이스 간의 이식성은 항상 중요하다.<br />
- O/R mapping은 관계형 DB를 사용할 때 항상 최선의 솔루션이다.</p>
<p>데이터 접근 전략을 사용할 때, 비즈니스 로직과 데이터 접근 로직을 추상화 계층으로 분리하는 것이 좋다.</p>
<p>Entity Beans</p>
<p>특정 DB에 종속되지는 않지만, EJB 컨테이너와 특정 O/R 맵핑 기술에 묶이게 된다. 성능이 안 좋다. 아키텍처적인 유연성이 떨어지고 테스트하기 어렵다.</p>
<p>EJB 2.0이 되고나서도, 너무 기초적인 O/R 맵핑인데다, 비효율적으로 관계형 DB를 사용하기 때문에 성능이 좋치 않다.</p>
<p>JDO</p>
<p>JDO는 엔티티 빈에 비해 성능이 좋고, 특정 RDBMS에 종속적이지도 않다. EJB에도 종속적이지 않다. 단점은&nbsp; JDO 구현체가 아직 비교적 성숙하지 못하다는 것이다. </p>
<p>다른 O/R 맵핑 솔루션</p>
<p>탑링크와 코코베이스는 JDO 보다 성숙한 O/R 맵핑 솔루션으로 대부분의 J2EE 애플리케이션에서 사용할 수 있다. 다양한 기능과, 고성능의 O/R 맵핑을 제공한다. (하이버네이트 얘기는 하나도 없지 왜..)</p>
<p>JDBC</p>
<p>암묵적인 J2EE에서 JDBC와 SQL은 악마라는 소문이있다. 하지만 이 책에서 제공하는 고 수준의 라이브러리를 사용하면 (이때부터 JdbcTemplate이 나오나 봅니다. 캬..) O/R 맵핑이 없는 상황에서 최선책이 될 수 있다. 제대로 사용하면 JDBC는 좋은 성능을 발휘할 것이다. 데이터를 자연스럽게 캐시할 수 있는 O/R 맵핑 계층이 있다면 JDBC는 적절하지 않다.</p>
<p><span style="font-weight: bold;"><span style="font-size: 10pt;">상태 관리</span></span></p>
<p>J2EE 아키텍처에서 또 다른 중요한 의사결정은 서버-측 상태를 어떻게 관리할 것이냐이다. 이것으로 인해 서버 클러스터 환경에서 애플리케이션이 어떻게 동작하는지 그리고 어떤 J2EE 컴포넌트를 사용해야 하는지 결정된다.</p>
<p>서버-측 상태가 필요한지 결정하는이 중요하다. 애플리케이션을 단일 서버에서 운영할 떄는 서버-측 상태를 유지하는 것이 별 문제는 아니다. 여러 서버를 클러스터 환경에서 운영한다면 페일오버(failover)나 server affinity 문제 등을 피하기 위해 서버-측 상태를 복사해야 한다.</p>
<p>서버-측 상태가 필요하다면 유지해야 할 양을 최소화 하는 것이 좋다.</p>
<p>서버-측 상태를 유지하지 않는 애플리케이션이 그러는 애플리케이션보다 확장성이 좋고, 간결하며 클러스터 환경에 배포하기 좋다.</p>
<p>서버-측 상태를 어디에 저정해야 할지 결정해야 한다. 저장할 정보의 종류에 따라 달라진다. 사용자 세션 정보냐, 비즈니스 객체 상태냐. 둘 다냐. 분산 EJB는 웹 단의 상태와 상관없이 stateless session bean으로 확장성을 최대화 한다.</p>
<p>J2EE는 웹 애플리케이션에서 상태 관리에 사용할 두 가지 옵션을 제공한다. HTTP session 객체와 stateful session EJB다.&nbsp; 상태 관리가 필요하다고 해서 EJB가 필요한건 아니다.<br />
<br style="font-weight: bold;" /><span style="font-weight: bold;"><span style="font-size: 10pt;">J2EE 아키텍처</span></span></p>
<p>생략~</p>
<p></p>
